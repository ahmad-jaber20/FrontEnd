on:
  push:
    branches: ["main"]

jobs:
  build:
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      # --- FIX: Calculate and Export Short SHA for Tagging ---
      - name: Calculate Short SHA for Image Tag
        # This takes the full SHA (e.g., a411ced12345...) and exports the first 7 characters (e.g., a411ced)
        # We need this to match the logic used in your Kubernetes deployment files.
        run: echo "SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.USR_TOKEN  }}



      - name: Build Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          file: Dockerfile
          build-args: |
            GITHUB_TOKEN=${{ secrets.USR_TOKEN }}
          push: true
          # --- FIX: Use the calculated SHORT_SHA here ---
          tags: ghcr.io/{{github.repository_owner}}/my-frontend:${{ env.SHORT_SHA }}
          # ----------------------------------------------

      # --- KUBERNETES AUTHENTICATION: This step provides kubectl access to the cluster ---
      # This is crucial. It uses a GitHub Secret (KUBE_CONFIG_YAML) containing the cluster configuration.
      - name: Configure Kubeconfig
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_YAML }}

      # 3. DEPLOY AND UPDATE IMAGE TAG (The solution for the image mismatch)
      - name: Update Deployment Image Tag
        # Define necessary deployment variables based on your existing setup
        env:
          FULL_SHA: ${{ github.sha }}
          NAMESPACE: frontend
          DEPLOYMENT_NAME: frontend
          CONTAINER_NAME: frontend
          IMAGE_REPO: ghcr.io/{{github.repository_owner}}/my-frontend
        run: |
          # The SHORT_SHA is already available
          SHORT_SHA=${FULL_SHA:0:7}
          NEW_IMAGE_TAG="${IMAGE_REPO}:${SHORT_SHA}"
          
          echo "Triggering deployment update in namespace ${NAMESPACE}."
          echo "New image tag: ${NEW_IMAGE_TAG}"
          
          # 3a. OPTIONAL: Apply manifests from the other repo's path (if this CI has access to the manifests repo)
          # If you cannot access the other repo, you must assume the base deployment already exists.
          # If the base deployment is already running, SKIP this step.
          # If you use Kustomize for overlays (as suggested by the -k), you might run this:
          # kubectl apply -k /path/to/manifests/stg 
          
          # 3b. CRITICAL STEP: Set the image. This command talks directly to the K8s API server.
          # It updates the image field in the running 'olive-assets' deployment from the old 
          # static tag (:stg-k8s) to the new dynamic tag (:a411ced), 
          # which immediately forces a pull and rolling update.
          kubectl set image deployment/${DEPLOYMENT_NAME} \
            ${CONTAINER_NAME}=${NEW_IMAGE_TAG} \
            --namespace=${NAMESPACE}
